##### Raft算法 ：所有的操作都类似二阶段提交，Leader在收到客户端的请求后不会立刻提交，而是写入日志中，
然后将该操作发送给follower，follower也不会立刻提交，而是写入自己的日志中并且回复Leader；过半数
写入成功后，Leader执行提交操作，并通知其他follower执行提交操作。


1. Leader选举问题
    - 首次选举：刚启动，第一次选举。
      - 节点一段时间内没有Leader消息，那么认为Leader不存在或者下线了。然后该节点成为候选者，
      并发起投票，他会投给自己一票，并把消息广播给其他节点。其他节点在一定的规则下进行比较，决定是否投给该候选者
      从而选出Leader。
    - 再次选举，Leader宕机或者下线。
      - 情况1：Leader下线了，处理操作首次操作一样。
      - 情况2：某些follower和Leader发生了通信问题，导致了网络分区，这时没有Leader的分区节点会进行一次选举。
        这种情况下，因为要求获得多数的投票才可以成为 Leader，因此只有拥有多数结点的分区可以正常工作。而对于少数的
        分区即便Leader任然存在，由于日志的节点数不能过半，不能成功提交成功。

    - 任期term：Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。每一个任期以一次选举作为起点，
        所以当一个结点成为 Candidate 并向其他结点请求投票时，会将自己的 Term 加 1，表明新一轮的开始以及旧 Leader 的任期结束。所有结点在收到比自己更新的 Term 之后就会更新自己的 Term 并转成 Follower，而收到过时的消息则拒绝该请求。

    - 投票：在投票时候，所有服务器采用先来先得的原则，在一个任期内只可以投票给一个结点，得到超过半数的投票才可成为 Leader，从而保证了一个任期内只会有一个 Leader 产生。
      投票由一个称为 RequestVote 的 RPC 调用进行，请求中除了有 Candidate自己的 term 和 id 之外，还要带有自己最后一个日志条目的 index 和 term。Candidate首先会给自己投票，
      然后再向其他节点收集投票信息，收到投票信息的节点，会利用如下规则判断是否投票：
      - 首先会判断请求的term是否更大，不是则说明是旧消息，拒绝该请求。
      - 如果任期Term相同，则比较index，index较大则为更加新的日志；如果任期Term不同，term更大的则为更新的消息。如果是更新的消息，则给Candidate投票
2. 日志同步问题
   Leader 会给每个 Follower 发送该 RPC 以追加日志，请求中除了当前任期 term、Leader 的 id 和已提交的日志 index，还有将要追加的日志列表（空则成为心跳包），前一个日志的 index 和 term。
   在接到该请求后，会进行如下判断：
   - 检查term，如果请求的term比自己小，说明已经过期，直接拒绝请求。 
   - 如果步骤1通过，则对比先前日志的index和term，如果一致，则就可以从此处更新日志，把所有的日志写入自己的日志列表中，否则返回false。

3. 安全性保证问题
   1. 已经commit的消息，一定会存在于后续的Leader节点上，并且绝对不会在后续操作中被删除。
   2. 对于并未commit的消息，可能会丢失。

