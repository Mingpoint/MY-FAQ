#### redis 持久化

##### redis aof 日志刷盘策略：

	1. Always, 每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘;性能最差，可靠性最高
	1. Everysec, 每个一秒钟刷盘一次，性能适中，可靠性适中
	1. No，由操作系统决定何时刷盘，性能最好，可靠性最差

##### AOF 重写机制

	1. 合并命令，例如：重写前，写入了两条命令：set name:limin ,set name:limincode;那么重写后就只会合并为一条命令 set 		name:limincode，因为后面这条会覆盖前面的命了，所以不用记录前面一条。这样文件体积就会变小。
	1. 新开一个新文件，重写完成后指向新文件

##### AOF重写机制流程

1. 主进程创建子进程，父子进程共享物理内存，重写子进程只会对这个内存进行只读
2. 主进程期间仍然可以正常工作，但是写入时，通过写时复制，会同时往 AOF 缓冲区和AOF 重写缓冲区(为了保证主进程与子进程数据一致性)
3. 子进程完成 AOF 重写工作完成后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。
4. 主进程收到该信号后做如下处理：
   1. 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致。
   2. 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。

##### AOF 和RDB区别

1. AOF日志记录的是操作命令
2. RDB是内存快照，记录的是数据，key-value
3. 恢复数据RDB比AOF快，但是可能存在漏数据的情况。

##### RDB 做快照时会阻塞线程吗？

1. 执行**save**命令会阻塞，因为是主进程执行。
2. 执行**bgsave**命令不会阻塞，因为是子进程执行。
3. 每次执行都是全量快照。

##### RDB 做快照策略

可以通过配置是实现：

```json
save 900 1
save 300 10
save 60 10000
```

只需要满足以上条件任意一个，就会执行**bgsave**命令，其含义：

	- 900 秒之内，对数据库进行了至少 1 次修改
	- 300 秒之内，对数据库进行了至少 10 次修改
	- 60 秒之内，对数据库进行了至少 10000 次修改



##### RDB bgsave 执行流程

1. 主进程创建子进程，子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响
2. 如果是写操作，通过**写时复制技术（Copy-On-Write, COW）** ；在主进程执行写操作，被修改的数据复制一份副本，然后通过bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。

##### 混合持久化

1. 混合持久化工作在 **AOF 日志重写过程**中实现的，当AOF 重写子进程重写时会先将RBD文件写入到AOF文件中。
2. 将AOF重新缓存区的命令写入到AOF文件中。
3. 混合持久化，AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**

#### 过期策略和内存淘汰策略

##### 过期删除策略: 键值对过期的删除策略

1. 定时删除：设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作
   - 优点：
     1. 及时删除，尽快释放内存
   - 缺点
     1. 在key 较多的情况下，增加cpu的消耗
2. 惰性删除：在查询时判断是否过期，过期就删除
3. 定期删除：每隔一段时间随机抽取部分key进行判断，过期就删除

**最佳实践**：惰性+定期删除

##### 内存淘汰策略: 内存达到最大限制了，内存的淘汰策略，与过期删除策略不一样

1. **不进行数据淘汰的策略** ：到达最大后不删除淘汰，继续写入直接报错
2. **进行淘汰策略**
   1. 设置过期时间的key 淘汰策略
      - volatile-random： 随机淘汰过期键
      - volatile-ttl：优先淘汰最早过期的键
      - volatile-lru：淘汰过期键中，最久未使用的键（根据时间来判断）
      - volatile-lfu：淘汰过期键中，最少未使用的键（根据使用次数来判断）
   2. 所有数据范围：
      - allkeys-random：随机淘汰任意键值
      - allkeys-lru：淘汰整个键值中最久未使用的键值
      - allkeys-lfu：淘汰整个键值中最少使用的键值

#### Redis 分布式锁

##### Redis 实现分布式锁有什么优缺点

- 优点：
  1. 性能高效
  2. 实现简单
- 缺点
  1. 过期时间不好把控
  2. 主备切换时，可能存在安全问题

##### 过期时间不好把控

**原因**：假设A线程获取到了锁，但是由于执行任务耗时过长，超过了Redis设置的超时时间，锁自动释放，B在去获取就可以获取到锁，这就造成了共享资源的没法受到锁的保护，而造成安全问题。

**解决方案**：超时续租，可以开启一个守护线程定时监控获得锁的线程是否完成任务，未完成可以续租锁，从而避免多个线程同时获得锁。推荐使用redission客户端的分布式锁方案(使用看门狗机制实现，即超过过期时间的1/3时续租)

**redission看门狗存在的问题**

**原因**：主备切换时，存在安全问题，例如：父A 节点，子B节点，当线程AA获取到锁后，由于主从复制时异步执行的，这个时候主节点挂了，还未来的急向B节点同步数据，这时候B节点通过哨兵模式自动升级为主节点B,但是没有线程AA的锁信息，其他线程则可继续加锁成功。

**解决方案** ： 使用RedLock 方案

##### RedLock 

1. 获取客户端的时间T1
2. 对A,B,C 三个节点，每个节点都进行加锁，锁的过期时间为T，A节点设置加锁动作的超时时间TA(一般远小于T，可能是1ms-50ms)，该锁在A节点的过期时间为A当前时间+T，B节点设置加锁动作的超时时间TB，该锁在B节点的过期时间为B当前时间+T，C节点设置加锁动作的超时时间TC，该锁在C节点的过期时间为C当前时间+T
3. 当超过一半的节点获取锁成功， 再次获取客户端时间T2，然后计算整个加锁耗时=T2-T1,如果T2-T1< T 获得锁，否则获取锁失败。

**RedLock缺点**

1. 对于部分应用场景而言太重了，需要去每个节点获取锁
2. 存在一定的安全隐患，由于A,B,C,D,E节点，假设客户端1获得A,B,C加锁成功，且时候顺序加锁，由于的加锁设置锁过期时间存在一定的差异，所以A节点的锁过期时间最短(MIN_TIME)=T-(C当前时间-B当前时间)，其余节点依次过期。假设客户端2获得D,E两个节点，在后获取A节点上的锁，这个时候假设A节点上的锁刚好过期了，客户端2获得A节点上的锁，超过一半，加锁成功，那么这个时候就表示存在客户端1和客户端2都得到了锁。

##### redis 单机不停机如何扩容？

1. 动态调整最大内存，Redis 支持动态调整 `maxmemory` 参数，可以在运行时通过 `CONFIG SET` 命令来调整 Redis 实例的最大内存。

#### Redis 集群

##### 主从架构

1. **主从复制**
   1. **第一次复制**
      1. 建立主从连接，第一次全量同步
         1. 从服务器向主服务器发送需要同步命令，命令包含两个参数，主服务器进程runID(第一次从服务不知道，所以为空),复制进度offset(第一次是-1,表示从头开始)
         2. 主服务器接收到命令后执行全量复制，并响应runID和offset给从服务器，从服务器记录下来。
      2. 主服务器同步数据给从服务器
         1. 主服务执行bgsave命令生成当前RDB文件，
         2. 从服务器清空内存，接收RDB文件并加装解析为key-value到内存中
         3. 主服务器在生成RDB快照，从服务接收快照，解析快照 这三个阶段，将新产生的数据写入到复制缓冲区中(replication buffer)
      3. 主服务器新的写操作同步从服务器
         1. 从服务器解析完成并加载到内存后，向主服务发送完成消息，主服务器将复杂缓冲区(replication buffer)的写命令发送给从服务器执行，这样就保证了主从数据的一致性。
   2. **增量复制** ：网络断开又恢复后，从主从服务器会采用**增量复制**的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。
      1. 从服务器在恢复网络后，向主服务器发送同步命令，带上offset的参数
      2. 主服务器接到命令后，执行continue命令，使用增量复制从服务器同步。
   3. **主服务器是如何知道哪些是增量数据呢？**
      1. repl_backlog_buffer,这是一个环形缓存区
      2. 主服务有一个master_repl_offset 标识自己在环形缓冲去中写的位置，
      3. master_repl_offset与从服务器中的位置比较，判断二者的差值，如果从服务器要读的数据还是环形缓冲区内，执行增量复制，否则执行全量服务于第一次复制一样。

##### 哨兵模式

​	哨兵主要负责：**监控，选主，通知**

###### 如何判断主节点真的故障了？

1. 哨兵每个一秒所有主节点，从节点发送ping命令，主从节点响应给哨兵，判断是否正常
2. 主节点在配置的时间内没有响应，则认为**主观下线**
3. 当某个哨兵节点认为某个主节点**主观下线**后，向其他节点发送命令，其他哨兵收到这个命令后，就会根据自己与这个主节点的通信情况发起投票，当有一半的哨兵节点认为该主节点下线后，则认为该主节点**客观下线**
4. 当某个主节点**客观下线**后，有发起的哨兵为leader对该主节点下的从节点进行选主。

###### 哨兵如何选举leader，当多个哨兵同时发现某个节点**主观下线**，如果确定那个为leader呢？

1. 每个候选者哨兵(发起主节点主观下线的哨兵节点) 都会投自己一票，然后向其他哨兵节点发起投票，其他哨兵节点先收到谁的投票请求就投谁。
2. 每个哨兵只能投一个票，投自己或者别人。

###### 如何通知子节点



##### 集群架构





