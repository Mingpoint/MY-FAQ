##### 索引怎么优化

1. 最左原则
2. Explain查看

##### 为什么用B+树,而不是B树

1. B+ 非叶子节点存储页指针和索引值，叶子节点存储真实数据，MySQL中存储的是Id,能储存的索引值多

2. 叶子节点之间是通过链表链接，这样的好处就是随机IO变为顺序IO

3. B树 是叶子节点和非叶子节点索引数据都存储，好处就是不需要回表，坏处就是存储量变小，意味着这树更高，需要磁盘IO次数更多，而且差个某个位于叶子节点的数据时，会把其他数据也查询道内存中，例如：A记录在叶子节点，B记录是A记录的父级节点，当查询A时，会从磁盘中读取B的数据记录。

4. 在MySQL中，读取索引是一页一页的读取到内存中的，每一页默认16k,B+树每一页存储的是下级页指针和索引值。

   假设 索引长度8字节，指针长度8字节，共16字节，叶子节点数据每条是1k,叶子节点页也就可以存储16条数据。

   那么现在b+树高 h = 3,可以算出：

   非叶子结点页 可存储的索引数量 = 16*1024 / (8+8) = 1024,现在有三层，

   第一层 根节点数量 = 1024

   第二层 非叶子节点数量 = 1024 

   第三层 叶子节点数量 = 1024  * 1024

   总数据量 = 1024  * 1024 * 16 = 16777216

##### 为什么不用hash索引

1. hash只能做等值查询
2. 排序处理不了
3. 由于hash冲突的存在，可能存在全表扫描的情况

##### Innodb 和 Myisam 的区别

1. Innodb 聚集索引，叶子节点存储的是数据; Myisam是非聚集索，叶子节点存储的是还是索引值，只不过有一个指向数据的指针。
2. Innodb 支持事务，Myisam 不支持事务
3. Innodb 支持行级锁，Myisam支持表级锁。

##### Innodb 行锁是如何实现的？

 ***注意***：Innodb 行锁 锁的是索引

1. InnoDB存储引擎有3种行锁的算法

   1. Record Lock: 单个记录上的锁
   2. Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上
   3. Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。

2. 规则

   ​	1. 在不通过索引条件查询时，InnoDB 会锁定表中的所有记录。所以，如果考虑性能，WHERE语句中的条件查询的字段都应该加上索引。

   2. InnoDB通过索引来实现行锁，而不是通过锁住记录。因此，当操作的两条不同记录拥有相同的索引时，也会因为行锁被锁而发生等待。

   3. 由于InnoDB的索引机制，数据库操作使用了主键索引，InnoDB会锁住主键索引；使用非主键索引时，InnoDB会先锁住非主键索引，再锁定主键索引。

   4. 当查询的索引是唯一索引(不存在两个数据行具有完全相同的键值)时，InnoDB存储引擎会将Next-Key Lock降级为Record Lock，即只锁住索引本身，而不是范围。

   5. InnoDB对于辅助索引有特殊的处理，不仅会锁住辅助索引值所在的范围，还会将其下一键值加上Gap LOCK。

   6. InnoDB使用Next-Key Lock机制来避免Phantom Problem（幻读问题）

##### 有几种事务隔离级别

1. **Read Uncommitted（读未提交）**：
   - 允许事务读取尚未提交的数据，可能会读取到其他事务未提交的脏数据。
   - 最低的隔离级别，会导致脏读（Dirty Read）。
2. **Read Committed（读已提交）**：
   - 保证一个事务不会读取到另一个事务未提交的数据，避免脏读。
   - 但是可能会出现不可重复读（Non-Repeatable Read）和幻读（Phantom Read）。
3. **Repeatable Read（可重复读）**：
   - 保证在同一个事务中多次读取同一行数据时，结果是一致的，不会受其他事务的影响。
   - 防止不可重复读，但仍可能出现幻读。
4. **Serializable（串行化）**：
   - 最高的隔离级别，确保事务之间的操作彼此完全隔离，就像事务是按顺序依次执行一样。
   - 防止脏读、不可重复读和幻读，但是性能较低，因为可能需要对数据进行串行化处理。

##### MVCC原理

MVCC 的核心思想是将每个事务的读操作与写操作解耦，通过保存数据的历史版本来实现并发控制。每个事务在开始时会创建一个读视图（Read View），用于确定在事务开始时可见的数据版本。读视图包含一个事务开始时的系统版本号，用于与数据行的版本号进行比较，以确定数据行是否对事务可见。

在 MVCC 中，当一个事务执行写操作时，会生成一个新的数据版本，并将旧版本的数据保存在回滚日志（Undo Log）中。这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免了幻读问题。

MVCC 工作流程如下：

1. 读操作：当一个事务执行 SELECT 语句时，会根据读视图的系统版本号和数据行的版本号进行比较，只读取在事务开始之前已经提交的数据行。这样，即使其他事务正在并发地插入或删除数据，事务仍然可以读取到一致的数据。
2. 写操作：当一个事务执行 INSERT、UPDATE 或 DELETE 语句时，会生成新的数据版本，并将旧版本的数据保存在回滚日志中。这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免了幻读问题。

##### MVCC解决幻读问题了吗？

1. 部分解决了
2. 在InnoDB中RR隔离级别读操作分为：
   1. 快照读：当前事务开启是创建的一个读视图，是当前事务的一个缓存，之后的所有查询都会从这里读取。
   2. 当前读：读取最新提交的数据，而不是基于事务一开始创建的视图
3. mvcc只解决 RR级别下，快照读的幻读情况，当前读则未解决，需要使用锁(Next-key Lock)来处理
4. 事务一开始就直接加锁(Next-key Lock)





